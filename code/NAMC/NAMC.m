% This has NO sigmoid adaptive beta scheme.
% Also contains a cure mechanism & energy calculations with overhead taken
% into account.
% PER calculation is based on SNRLIMITS taken directly from Giannaki
% result!
% Uses new MASS algorithm from April 4th
% Implements use of AMC and adaptive beta <------------*
% Adjacency matrix is symmetrical
% Includes additional superimposed bursty noise on top of the AWGN
% Re-imported AWGN
% Improved intialisation of TC2FC, T2FC, DUPT
% Introduced more (18) allowed beta values
% Removed noise bursts; back to pure AWGN
% Introduced more (25) allowed beta values
% Changed Gaussian noise to memoryFUL Gaussian noise
% Introduced decisions as to what policy to follow: change beta/mode
% Introduced calculation of known neighbors
% Corrected calculation of PER in the decision making loops
% Introduced energy cost calculation in decision making and I choose...
% ...maximum Pinf/Cost
% Introduced my new Pinf calc... :-)
% Introduced dynamic reset size
% Corrected Energy Cost calculations
% Corrected OVERHEAD matrix
% Corrected metric calculation
% Included node index in METRIC, PINF, ENERGYCOSTCALC calculations
% Using the X" calculation for Pinf=(1-PER)(1-?)^n
% 27.01.2012 20:08
% -----------------
% 02.02.2012 19:39
% Calculated popularity of policies
% 09.02.2012 19:22
% Introduced new metric: Cost_save*infectionProb
% I enhanced arbitrarily some policies with a multiplic weight
% I removed the adaptivity of the resetsize temporarily because it is confusing
% Introduced line 424->else MODECALC(2,i) = MODE(i); % MODECALC SHOULD NOT STAY 0
% Introduced factor 0.01*abs(randn(1)) in metrics calc for policy choice...
% ...to avoid "draw" i.e. equal values
% 09.02.2012 20:25
% Instead of adding 0.001*abs(randn(1)), I multiply with
% (1+0.01*abs(randn(1))), i.e. create a deviation of O(1%)
% Replaced neighcount with NEIGHCOUNT(i) - more consistent
% 20.02.2012 19:14
%%%%%%%%%%%%%%%%%
% 06.03.2012 19:26
% Added calculation of metrics for 90% coverage
% 06.03.2012 20:31
% Changed order of result printout
%%%%%%%%%%%%%%%%%
% 02.04.2012 20:41
% modified calculation of E2FC to ignore zero values
%%%%%%%%%%%%%%%%%
% 25.04.2012 20:41
% slightly modified output layout
%%%%%%%%%%%%%%%%%%
% 07.05.2012 00:29
%Use total number of neighbors, NOT known neighbors
%Maximum cost=Cost(Rc=1/2, beta=1)
%New equation for P_sr
%%%%%%%%%%%%%%%%%%
%09.05.2012 02:15
%Eval Metric = PINF*CostSave
%%%%%%%%%%%%%%%%%%
%14.10.2012 09:34
%Changed moise statistics to non-Gaussian
%%%%%%%%%%%%%%%%%%
% 30.12.12 20:01
% Put exact Yannaki's thresholds - not 20% doped!
% SNR is read from a file generated by Zerva's code
%%%%%%%%%%%%%%%%%%
% 02.01.13 21:08
% Channel status decided according to te FSMC change of stste
%%%%%%%%%%%%%%%%%%
% 04.02.13 01:08
% CHANSTATETEMP & CHANSTATE calculation corrected.
%%%%%%%%%%%%%%%%%%
% 08.01.13 01:28
% Re-activated the policy-selection algorithm
%%%%%%%%%%%%%%%%%%
% 08.01.13 18:56
% Introduced NOISET(node,time) in addition to NOISE(node)
% Fixed average noise calculation over a sliding window: AVENOISET(node,time)
%%%%%%%%%%%%%%%%%%
% 12.01.13 18:56
% The channel state FSMC was modified:
% Abolished the CHANSTATETEMP and now use the CHANSTATE straight away.
% No two statements need to access the same matrix concurrently.
% The state DOES change at every time slot!
%%%%%%%%%%%%%%%%%%
% 16.01.13 01:16 & 18:11
% Replaced utility function with its averaged version over the sliding window
% U(i,t)-->AVEUT(i,t)
%%%%%%%%%%%%%%%%%%
% 17.01.13 01:16 & 19:26
% Modified stopping criterion as follows:
% OLD: if AVEUT(i,t)>max(AVEUT(i,t-1))  
% NEW: if U(i,t)>max(AVEUT(i,t-1))  
%%%%%%%%%%%%%%%%%%
% 20.01.13 11:22
% Added mode temporal evolution for each node:
% MODEDET(time,node) i.e. MODE DETAILED  
%%%%%%%%%%%%%%%%%%
% Added  CHANSTATET(t,node)
%%%%%%%%%%%%%%%%%%
% Changed Utility function; now utility = metric (from policy scheme)
%%%%%%%%%%%%%%%%%%
% 28.01.13 20:40
% Fixed bug in markov refresh
%
%%%%%%%%%%%%%%%%%%
%31.01.13 18:30
%Added calculation for... 
%Chanstateavevstime
% ... takes all iterations into account
%%%%%%%%%%%%%%%%%%
%31.01.13 19:50
%Added a new metric... 
% METRIC4(policyindexx,i) = PINF(pindex,i) - ENERGYSPENT(i)/(maxcostsingle*t);
% ... and put indices to METRICs sop that we can choose easily
%%%%%%%%%%%%%%%%%%
% 04.02.13 20:22
% Randomised the beta initial values
% Want to do the same with the initial channel state & mode.
%%%%%%%%%%%%%%%%%%
% 08.02.13 00:32
% Randomised the initial mode
% Also sliding window was made equal to the lifetime of
% the current mode for the specific node! instead of constant
%%%%%%%%%%%%%%%%%%
% 12.02.13 00:46
% Correction to the previous:
% Sliding window was made equal to the lifetime of
% the current FSMC STATE =(beta,mode) for the specific node! instead of constant
%%%%%%%%%%%%%%%%%%
% 22.02.13 20:56
% Added square function FLAP(t) to use on "flapping interfaces"
%%%%%%%%%%%%%%%%%%
% 25.02.13 19:46
% METRIC4 used as Utility function; falls wthin the form: U = q-?*c
%%%%%%%%%%%%%%%%%%
% 26.02.13 23:59
% METRIC5 introduced
%%%%%%%%%%%%%%%%%%
% 11.03.13 18:26
% Corrected the strings str131-str134: the policies descriptions were wrong
% Also added NOISEPURE(node)
%%%%%%%%%%%%%%%%%%
% 14.03.13 18:41
% Introduced METRIC6 = DUPRATE - NEC
%%%%%%%%%%%%%%%%%%
% 14.03.13 19:23
% Re-defining NOISE & SNR as a link property, not a node property
%%%%%%%%%%%%%%%%%%
% 18.03.2013
% Turned some node properties to link properties
% NOISE, SNR, CHANSTATE, etc
%%%%%%%%%%%%%%%%%%
% 19.03.2013 19:38
% Will change node's mode selection
% by introducing S2 = mean(SNR,2)
%%%%%%%%%%%%%%%%%%
% 20.03.13 19:20
% BUG FIX :-D
% Moved SNR & NOISE initialisation inside iteration loop!!
%%%%%%%%%%%%%%%%%%
% 20.03.13 19:35
% For every node I will keep a matrix SSS(node,chosen_state)
% Based on this I will calculate expected future utility
%%%%%%%%%%%%%%%%%%
% 20.03.13 20:22
% Policy popularities exressed as proportions, not absolute numbers
%%%%%%%%%%%%%%%%%%
% 24.04.13 18:32
% Added normalized cost for node state changes = changes_count/timeslots...
% ...hence introducing METRIC7
%%%%%%%%%%%%%%%%%%
% 07.05.13 16:32
% Only changed some text in the diary
%%%%%%%%%%%%%%%%%%
% 07.05.13 19:28
% Script for STATIC scheme; based on the AAMC204.m script
%%%%%%%%%%%%%%%%%%
% 14.05.13 20:08
% Script for STATIC scheme; based on the AAMC204.m script
% Re-introduced the Yannakis-based mode switching
%%%%%%%%%%%%%%%%%%
% 21.05.13 17:05
% Correction: the TM we open is 6x6
% hence... STATES = [1 2 3 4 5 6]
%%%%%%%%%%%%%%%%%%
% 30.05.13 23:41
% 1) Introduced changes_count_global(node,time,iteration)
% 2) Correcting calculation of the METRIC7
% (changes_count(i,t) was always zero!)
% 3) Now it is also cumulative
%%%%%%%%%%%%%%%%%%
% 03.06.13 19:30
% Modified bursty noise from
% FLAP(t) to FLAP(node,t,iteration)
%%%%%%%%%%%%%%%%%%
% 21.07.13 12:55
% Based on NAMC208
% 1. Made it callable with 
% iterations & time (T)
% as arguments
% 2. The starting *clear* line is deleted!
% Careful to *clear* before running, as follows:
% > clear
% > run NAMC(80,100)
% 3. Changed filename when saving.
%%%%%%%%%%%%%%%%%%%
% 22.07.13 19:56
% Introduced SUCCESSFUL_INF_COUNT
% Introduced effective goodput (g_eff) calculation
% Watch line:
% " % MODESTART = MODE;  % do we need this here?" Do we??
%%%%%%%%%%%%%%%%%%%

% clear
% clc
function [] =NAMC(T,iterations);
zz = clock;
disp('start timestamp:');
zz

numberofbetas = 25;
deltabeta = 0.02;

for inindex=1:numberofbetas
    BETAS(inindex)=0.20+inindex*deltabeta;
end
BETAS;

MODES = [1 2 3 4 5 6];
STATES = [1 2 3 4 5 6];
% STATES = [1 2 3 4 5 6 7 8];

N = 50; % number of nodes
N2 = N*N;
% b0 = BETAS(10); % original beta
%T = 600; % number of temporal iterations  <-----
I = 1; % number of originally infected nodes
loss = 0.8; % this is essentially BER (attention, not PER!!)
%gaussianoise = randn(1);   %no need to define here
signal = 30e+015;
n0 = 15;
sigma = 7;
deltaoverbeta = 0.1;
% d0 = b0*deltaoverbeta;  % not used
netdens = 0.85;
% delta = beta/5
betasum = 0;
pktsize = 50; % packet size in bits
bitTxcost = 720; %bit transmission energy cost in nJ
bitRxcost = 110; %bit reception energy cost in nJ
instructioncost = 4;
nb = 45; %amplitude of noise burst
trainprob = 0.2; %probability that a noise burst occurs
%iterations = 10; %algorithm's iterations <-----
numberofthresholds = 8; % number of SNR limits - switching thresholds
startingmode = 3;
resetsize=7;
weight = 1.0;
% window = 40; % sliding window size *******************************!!!
startingchannelstate = 3;
ebase =2718; % t/T > 1/ebase is the theshold for the opt stop condition eval 2 start
actualtime = 0;
maxcostsingle = 1.8*pktsize*bitTxcost; % this is max cost for a SINGLE transmission

berrors = 0;
bergood = 0;
disp('  ');
disp('===RUNNING===')
disp('Static scheme')

 % SNRLIMITS calculation:
 
 %This holds for uncoded transmission
 
%BER0 = 10^(-4); % assumption for desired PER
%K0=-log(5*BER0);
                      
%for index = 1:numberofthresholds+1
%    SNRLIMITS(index) = (2/3)*K0*((2^index)-1);
%end
%SNRLIMITS(2) = (erfcinv(2*BER0))^2;

% Taken from Giannaki directly (Fig. 10) - pls compare with fsr.m file
%     GPNs are fine acc. to Yannaki!  
    
    GN(1)=7.9932;
    GN(2)=3.4998;
    GN(3)=1.6883;
    GN(4)=0.6644;
    GN(5)=0.3756;
    GN(6)=0.09;
    
%     GPNs are fine acc. to Yannaki!   
    
    AN(1)=274.7229;
    AN(2)=90.2514;
    AN(3)=67.6181;
    AN(4)=50.1222;
    AN(5)=53.3987;
    AN(6)=35.3508;

%     GPNs are fine acc. to Yannaki!
    
    GPN(1)=0.7026;
    GPN(2)=1.2865;
    GPN(3)=2.4959;
    GPN(4)=5.89;
    GPN(5)=10.5896;
    GPN(6)=39.6278;
    GPN(7)=10; % programming trick; the value (10) is arbitrary but non-void ;-)
    
% SNRLIMITS(1) = 0.707946;
% SNRLIMITS(2) = 1.542447;
% SNRLIMITS(3) = 3.928036;
% SNRLIMITS(4) = 7.393091;
% SNRLIMITS(5) = 12.98697;
% SNRLIMITS(6) = 23.93639;
% SNRLIMITS(7) = 125.8925;

    % for simplicity SNR threshold = gamma_pn; see later
    
for anindex = 1:7
        SNRLIMITS(anindex)=GPN(anindex);
end

for iuiu = 1:7
    NOISELIMITS(iuiu)=signal/SNRLIMITS(iuiu);
end
SUCCESSFUL_INF_COUNT_GLOBAL = zeros(iterations,N);

% These are the above from Giannaki doped +20%

% SNRLIMITS(1) = 0.8495352;
% SNRLIMITS(2) = 1.8509364;
% SNRLIMITS(3) = 4.7136432;
% SNRLIMITS(4) = 8.8717092;
% SNRLIMITS(5) = 15.584364;
% SNRLIMITS(6) = 28.723668;
% SNRLIMITS(7) = 151.071  ;

%for index = 1:iterations
%    TC2FC(index)=0;
%    T2FC(index)=0;
%end	
%

% Flapping function; it's a square function
% Moved it out of the loop for simplicity

FLAP=zeros(N,T,iterations);
ft = int16(5*rand(N,T,iterations));        % burst duration
jitter = -1 + 2*int16(10*rand(N,T,iterations));% jitter of burst start

for iteration100 = 1:iterations
    for node100 = 1:N
        for f = 1:T
            if mod(f,25) == 0
                for ff = f+jitter(node100,f,iteration100):f+ft(node100,f,iteration100)
                    FLAP(node100,ff,iteration100) = 2;
                end
            else
                % do nothing
            end
        end
    end
end

%

changes_count_global = zeros(N,T,iterations);

for iteration = 1:iterations
    iteration
    	%disp('start of iteration...')
    	%iteration      

% some additional initialisation start

% SSS(node,chosen_policy)
SSS = zeros(N,4)+0.25;
changes_count = zeros(N,T);
SUCCESSFUL_INF_COUNT = zeros(1,N);
% % S(node,orig_beta,orig_mode,final_beta,final_mode)
% S = zeros(N,length(BETAS),length(MODES),length(BETAS),length(MODES));

for iindexxx = 1:N;
    for jjindexxx = 1:N;
    randostate(iindexxx,jjindexxx) = rand;
    if randostate(iindexxx,jjindexxx) <= 0.0830
       randostate(iindexxx,jjindexxx) = 0.09;% so that (length(STATES)*randostate(node)) >= 0.5
    end
    end % jjndexxx
end % iindexxx

for iindexx = 1:N;
    for jjindexx = 1:N;
        NOISE(iindexx,jjindexx) = n0;       
        CHANSTATE(iindexx,jjindexx) = STATES(max(1,  int16(length(STATES)*randostate(iindexx,jjindexx))  ) ); % random original channel state; initialize matrix with channel states (->SNR) as perceived by EACH NODE!!
        CHANSTATETEMP(iindexx,jjindexx) = CHANSTATE(iindexx,jjindexx);        
        for ttindex = 1:T;
            SNR(iindexx,jjindexx,ttindex)= 0;
            NOISET(iindexx,jjindexx,ttindex) = n0;
            NOISEPURET(iindexx,jjindexx,ttindex) = n0;            
            RECENTNOISE(iindexx,jjindexx,ttindex) = n0;            
            AVENOISET(iindexx,jjindexx,ttindex) = n0;
        end % ttindexx
    end % jjindexx
    S2 = mean(SNR,2);
end % iindexx

%
    TC2FC(iteration)=0;
    T2FC(iteration)=0;
    E2FC(iteration)=0;
    
    TC29C(iteration)=0;
    T29C(iteration)=0;
    E29C(iteration)=0;    
    
     for policyindex=1:4;
         POLICYCHOSENI(iteration,policyindex)=0;
     end

% POLICYCHOSENI=0;

% Flapping function; it's a square function
% Moved it out of the loop for simplicity
% 
%  ft = 3; % flapping duration
%  for f = 1:T
%      if mod(f,25) == 0
%          for ff = f:f+ft
%              FLAP(ff) = 2;
%          end
%      else
%          % do nothing
%      end
%      
%  end
% 
% %
    
    for t=1:T;
        DUPT(t,iteration)=0;
    end

% some additional initialisation end
	A(1) = 1;
    ATEMP(1) = 1;
	for k = 2:N
	    A(k) = 0;
        ATEMP(k) = 0;
    end

for node10 = 1:N
    randobeta(node10) = rand;
    if randobeta(node10) <= 0.02 % (length(BETAS)*randobeta(node))
        randobeta(node10) = 0.022;
    end
end % node10 ...is an index only

for node11 = 1:N
    randomode(node11) = rand;
    if randomode(node11) <= 0.0833 % so that (length(MODES)*randomode(node)) >= 0.5
        randomode(node11) = 0.09;
    end
end % node11 ...is an index only

% for node12 = 1:N
%     randostate(node12) = rand;
%     if randostate(node12) <= 0.0626 % so that (length(STATES)*randostate(node)) >= 0.5
%         randostate(node12) = 0.0626;
%     end
% end % node12 ...is an index only

        % importing data according to SoS model start
         open transMatrix_nfsr_08.mat;
         TM = ans.TM_ave;
         clear ans;
        % importing data according to SoS model end

        % The following small initialisation was in the nodes loop!!
        % 101% needless!
       for t=1:T;
            nodenoise(t) = 0; % dummy initialization of nodenoise
            g(t)=0.5*randn(1);
       end        
        
        DUPRATE_NO_TIE_INS = 0.01*abs(randn(N,T));
%         DUPRATE_NO_TIE_INS = zeros(N,T);        
        DUPRATE_NO_TIE = zeros(N,T);

	for node = 1:N
%         B(node) = b0;
        B(node) = BETAS(int16(length(BETAS)*randobeta(node))); % random original beta
	    TX(node) = 0;
	    RX(node) = 0;
	    TXTEMP(node) = 0;
	    RXTEMP(node) = 0;
	    ERR(node)=0;
	    ERRTEMP(node)=0;
	    DUP(node)=0;
	    DUPTEMP(node)=0;
	    BTEMP(node)=0;
      SUCCESSFUL_INF_COUNT_TEMP(node) = 0;	    
	    % MODE(node)=startingmode; %initialise matrix with encoding modes
        MODE(node)= MODES(int16(length(MODES)*randomode(node))); % random original mode
	    MODETEMP(node)= MODE(node); % arbitrary; value plays no role
        nodenoise(node) = 0;
        avenoise(node) = 0;
%         CHANSTATE(node) = startingchannelstate; % initialize matrix with channel states (->SNR) as perceived by EACH NODE!!
%         CHANSTATETEMP(node) = startingchannelstate;
%         CHANSTATE(node) = STATES(int16(length(STATES)*randostate(node))); % random original channel state; initialize matrix with channel states (->SNR) as perceived by EACH NODE!!
%         CHANSTATETEMP(node) = CHANSTATE(node);
        % The possible values of CHANSTATE form a markov chain (FSMC).
        % One state for each SNR interval.
        WINDOW(node) = 1;

%        for t=1:T;
%            nodenoise(t) = 0; % dummy initialization of nodenoise
%            g(t)=0.5*randn(1);
%        end
     
        % importing data according to SoS model start

        % Took these out of the nodes loop
         
        % importing data according to SoS model end        
        
%         for othernode=1:N;
%                     PERCEIVEDADJ(node,othernode) = 0; % PERCEIVED
%                     adjucency matrix! = KNOWN neighbors % moved down
%         end

        BFACTOR(node) = 0;
        ENERGYSPENT(node)=0;
        ENERGYSPENTTX(node)=0;
        ENERGYSPENTRX(node)=0;
        OVERHEADBITSENT(node)=0;
%         PER(node) = 0;
        BITSENT(node)=0;    % Number of bits sent by a node. So that when I sum up for all nodes I get the total bits sent.        
        %BER(node) = loss;
        %PER(node) = AN(MODE(node))*exp(-GN(MODE(node))*SNR(node));
        UP(node) = 0; % number of times the beta has been forced up when minimum SNR-limit reached - ACCORDION-RELATED
        DOWN(node) = 0; % number of times the beta has been forced down when maximum SNR-limit reached - ACCORDION-RELATED        
        DOWNMODE(node) = 0;
        UPMODE(node) = 0;   
        DUPRATE(node) = 0;
        ERRRATE(node) = 0;
        ERRRATETEMP(node) = 0;
        DUPRATETEMP(node) = 0;
%         NOISE(node) = n0;
%         NOISEPURE(node) = n0;        
        for time=1:T
%             NOISET(node,t) = n0;
%             NOISEPURET(node,t) = n0;            
%             RECENTNOISE(node,t) = n0;            
%             AVENOISET(node,t) = n0;
            RECENTUT(node,t) = 0;
            AVEUT(node,t) = 0;
            U(node,t) = 0;
            MODEDET(t,node) = startingmode; % MODEDET(= mode detailed) like MODE(node) but keeps temporal evolution too
%             CHANSTATET(t,node) = startingchannelstate;
            
%             BDET(t,node) = b0; % BDET(= beta detailed) like B(node) but keeps temporal evolution too
            BDET(t,node) = B(node); % BDET(= beta detailed) like B(node) but keeps temporal evolution too            
        end
        
%        MODESTART = MODE;              % do we need this here?
        
        for policyindex=1:4
            POLICYCHOSEN(node,policyindex) = 0;
        end
        
        for othernode=1:N
            UPIFSMC(node,othernode) = 0; % state increment count for channel status (input FSMC)
            DOWNIFSMC(node,othernode) = 0; % state increment count for channel status (input FSMC)
            SWITCHIFSMC(node,othernode) = UPIFSMC(node,othernode) + DOWNIFSMC(node,othernode);
            UPIFSMCTEMP(node,othernode) = 0;
            DOWNIFSMCTEMP(node,othernode) = 0;   
            CHANSTATET(t,node,othernode) = startingchannelstate;
            PER(node,othernode) = 0;      
            NOISEPURE(node,othernode) = n0;        
            PERCEIVEDADJ(node,othernode) = 0; % PERCEIVED adjucency matrix! = KNOWN neighbors            
        end
        
    end
    
            % Decision matrix initialization    
        for a = 1:N;        % number of nodes
            for b = 1:4;    % number of possible actions

                    BCALC(b,a) = B(a);
                    MODECALC(b,a) = 3;
                    PERCALC(b,a) = 0; % intitialization reasons           
            end
        end
    
    %Overhead for each encoding mode
    OVERHEAD(1)= 2; % overhead factor= 1/(coding rate); code rate shows the useful data proportion, overhead shows the overhead(!) proportion
    OVERHEAD(2)= 2;
    OVERHEAD(3)= 1.3333; % 4/3;
    OVERHEAD(4)= 1.7778; % 16/9
    OVERHEAD(5)= 1.3333;
    OVERHEAD(6)= 1.3333;

	for mm = 1:N
	    ADJ(mm,mm) = 1;
	end
    NC = sum(ADJ);
    for node=1:N;
        NEIGHCOUNT(node) = NC(node);  % <-- ALL nodes, assumed known from beacons!	    
    end    
    
%    	for t = 1:T  % put this here for node mobility   
	% Adjacency matrix start    
	ADJ = rand(N,N);
	for m = 1:N
	    for n = 1:N
	        if ADJ(m,n)>netdens;
	            ADJ(m,n) = 1;
                ADJ(n,m) = 1;                
	            %disp(ADJ(m,n))     
	        else
	            ADJ(m,n) = 0;
                ADJ(n,m) = 0;                  
	            %disp(ADJ(m,n))
	        end           
	    end
	end
	%disp('ADJ matrix is...')
	%ADJ
	% Adjacency matrix end        

	% Now attempt to infect
	%disp('===NOW ATTEMPT TO INFECT===')
    	for t = 1:T % put his here for NO node mobility
            actualtime = actualtime + 0.001;

% Refresh channel state markov chain for all LINKS (NOT nodes) start    

for node20 = 1:N
    for node21 = 1:N
%        a = 1:8;             %# possible channel states - modes
        a = 1:length(STATES);    %# possible channel states - modes
        weight = TM(CHANSTATE(node20,node21),:); %# corresponding weights
        results = 1;              %# how many numbers to generate
        R = a( sum( bsxfun(@ge, rand(results,1), cumsum(weight./sum(weight))), 2) + 1 );
        CHANSTATETEMP(node20,node21) = R;
%     ---------
        if CHANSTATETEMP(node20,node21) > CHANSTATE(node20,node21)      
            UPIFSMCTEMP(node20,node21) = UPIFSMCTEMP(node20,node21) + 1;
        end
        if CHANSTATETEMP(node20,node21) < CHANSTATE(node20,node21)
            DOWNIFSMCTEMP(node20,node21) = DOWNIFSMCTEMP(node20,node21) + 1;
        end
%     ---------
    end  % node21
end % node20

CHANSTATE = CHANSTATETEMP;
DOWNIFSMC =DOWNIFSMCTEMP;
UPIFSMC = UPIFSMCTEMP;
SWITCHIFSMC = DOWNIFSMC + UPIFSMC;
CHANSTATET(t,:,:) = CHANSTATE;  

% Refresh channel state markov chain for all LINKS (NOT nodes) end

        for node = 1:N  
            
            for othernode = 1: N % othernode
                if CHANSTATE(node,othernode)~=7
                    NOISEPURE(node,othernode) = (  NOISELIMITS(CHANSTATE(node,othernode)) + ( NOISELIMITS(CHANSTATE(node,othernode)+1)-NOISELIMITS(CHANSTATE(node,othernode))   )*randn(1,1)  ); % noise randmoly between limits
                    NOISE(node,othernode) = (1+FLAP(node,t,iteration)) * NOISEPURE(node,othernode); % noise randmoly between limits
%                     NOISE(node,othernode) = NOISEPURE(node,othernode); % no BURSTY noise
                else
                    if CHANSTATE(node,othernode)==7
                        NOISE(node,othernode) = NOISELIMITS(7)*(1+rand);
                    end
                end          
            
            NOISET(node,othernode,t)=NOISE(node,othernode);
            NOISEPURET(node,othernode,t)=NOISEPURE(node,othernode);            
            SNR(node,othernode,t)= signal/(NOISET(node,othernode,t)); % Populate signal-to-noise matrix: a value for each node and timeSLOT.     
            S2=mean(SNR,2);
            M = 2^(MODE(node));
            BER(node,othernode) = 0.2*exp(-3*SNR(node,othernode,t)/(2*(M-1)));         
  
           end % othernode 
                   
            % use Giannaki for PER calculation:
            for othernode=1:N
                if SNR(node,othernode,t)>GPN(MODE(node))
                    PER(node,othernode) = AN(MODE(node))*exp(-GN(MODE(node))*SNR(node,othernode,t));
                    elseif (SNR(node,othernode,t)<GPN(MODE(node)) && SNR(node,othernode,t)>0)
                    PER(node,othernode) = 1;                
                end
                         
            if PER(node,othernode)>1            
                %disp('***PER ALARM !!!***');
                %disp(PER(node));
                berrors = berrors +1;
                PER(node,othernode) = 1;
            else bergood = bergood+1;
            end % if
            end % othernode
        end

     
	    for i = 1:N
	        %attempt to cure
	        cure = rand;
	        if cure < B(i)*deltaoverbeta;
	            A(i) = 0;
            end
            lucky = rand;
	        if lucky < B(i) %#ok<ALIGN> % here we make the beta experiment ONCE for each node: broadcast!
	          for j = 1:N %#ok<ALIGN>
	             if A(i) == 1 %#ok<ALIGN>
	               if ADJ(i,j) == 1 && (i ~= j) %#ok<ALIGN>
% 	                   lucky = rand;
% 	                   if lucky < B(i)  % here we make the beta experiment on a p2p basis!
% 	                       TXTEMP(i)=TX(i)+1;
%                          ENERGYSPENT(i)=ENERGYSPENT(i)+pktsize*OVERHEAD(MODE(i))*bitTxcost; % Tx energy MUST be calculated ONCE for every broadcast!!
%                          BITSENT(i) = BITSENT(i) + pktsize + pktsize*OVERHEAD(MODE(i));
%                          OVERHEADBITSENT(i)=OVERHEADBITSENT(i)+pktsize*OVERHEAD(MODE(i));
	                       RXTEMP(j)=RX(j)+1;
                           
%                          Add a new known neighbor; if it already known the element (j,i) is already =1 
                           PERCEIVEDADJ(i,j) = 1;       % i.e. node j becomes aware of its neighbor i
% 
                           % the following line is Rx energy spent
                           ENERGYSPENT(j)  =ENERGYSPENT(j)  +pktsize*OVERHEAD(MODE(i))*bitRxcost+2*instructioncost; %packet size decided by sender's code rate!
                           ENERGYSPENTRX(j)=ENERGYSPENTRX(j)+pktsize*OVERHEAD(MODE(i))*bitRxcost+2*instructioncost; %packet size decided by sender's code rate!                           
	                       channel = rand;
	                       if channel > PER(i,j) %loss - PER(i,j) NOW! i=src, j=dst   ***PER(i,j)
	                           if A(j)==0
	                               ATEMP(j)=1;
                                   SUCCESSFUL_INF_COUNT_TEMP(j) = SUCCESSFUL_INF_COUNT(j)+1;	                               
	                           else
	                               DUPTEMP(j)=DUP(j)+1;
	                           end
	                       else
	                           ERRTEMP(j)=ERR(j)+1;
	                       end % loss
% 	                   end % lucky % here we make the beta experiment on a p2p basis!
	                  end % ADJ
	               end % A(i)
	            end % j
                TXTEMP(i)=TX(i)+1;                
                ENERGYSPENT(i)  =ENERGYSPENT(i)  +pktsize*OVERHEAD(MODE(i))*bitTxcost; % energy calculated ONCE for every broadcast!!
                ENERGYSPENTTX(i)=ENERGYSPENTTX(i)+pktsize*OVERHEAD(MODE(i))*bitTxcost;
                BITSENT(i) = BITSENT(i) + pktsize + pktsize*OVERHEAD(MODE(i));
                OVERHEADBITSENT(i)=OVERHEADBITSENT(i)+pktsize*OVERHEAD(MODE(i));                
             end % lucky % here we make the beta experiment ONCE for each node: broadcast!
	       
	       %Calculate next beta & encoding mode
	       if RX(i)~=0
	            %BTEMP(i)= b0*(1+ERR(i)/RX(i)-DUP(i)/RX(i));
	            ERRRATE(i)=ERR(i)/RX(i);
	            DUPRATE(i)=DUP(i)/RX(i);
                
	            ERRRATETEMP(i)=ERRTEMP(i)/RXTEMP(i);
	            DUPRATETEMP(i)=DUPTEMP(i)/RXTEMP(i);                
                
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                % START the Giannakis mode choosing -------------------------   
                               
                % set MODE according to SNR limits...
                % that is when SNR-thresholds are crossed
                % and NEVER change beta
                
                for gindex = 1:6
                    if SNR(i,j,t) < GPN(gindex)+1 || SNR(i,j,t) >= GPN(gindex)
                        MODETEMP(i) = gindex;
                    end
                end
                             
                % END the Giannakis mode choosing -------------------------   
               
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% mean number of neighbors

 neighcount = NEIGHCOUNT(i);
 
 for method = 1:4;
     for peer_of_i = 1:N
            PINF(method,i,peer_of_i)=0;
     end   % peer_of_i
            PINFAUX(method,i) = 0;
            ENERGYSPENTCALC(method,i)=0;
            ENERGYSPENTTXCALC(method,i)=0;
            ENERGYSPENTRXCALC(method,i)=0;     
end
 
%  for dynresetsize=1:resetsize; % dynresetsize

% S2 = mean(SNR,2);
% if SNR(i,t)>SNR(i,t-1)        % I CHECK BEFORE CHANGING B ****************************** DILEMMA!!
if S2(i,:,t)>S2(i,:,t-1)  
    BFACTOR(i) = 1;
    MODEFACTOR(i) = 1;
else BFACTOR(i) = - min(B(i)/deltabeta,resetsize);
% else BFACTOR(i) = - min(B(i)/deltabeta,dynresetsize );
     MODEFACTOR(i) = - 1;
end

% Start of sliding window calculation

    swindow = 1;
    %swindow = min(3,t-1);
    %swindow = min(WINDOW(i),t-1);
    %swindow = min(2*WINDOW(i),t-1);
    %swindow = t-1;
    
    % you can set different window sizes to play; change the wiwindow value
    %wiwindow = 1;
    %swindow = min(wiwindow,t-1);
    %
    
    RECENTNOISE(i,t-swindow:t) = NOISET(i,t-swindow:t);
    AVENOISET(i,t) = mean(RECENTNOISE(i,t-swindow:t));
    RECENTUT(i,t-swindow:t) = U(i,t-swindow:t);
    AVEUT(i,t) = mean(RECENTUT(i,t-swindow:t));
    DUPRATE_NO_TIE(i,t) = mean(DUPRATE_NO_TIE_INS(i,t-fix(0.2*swindow):t));    
    
% End of sliding window calculation


 % Start of different options - policies 
% % Policy #1 - keep mode, change beta

 BCALC(1,i) = B(i) + BFACTOR(i)*deltabeta;

 PINF(1,i) = (0.01*abs(randn(1)) + 1)*(1-BCALC(1,i)/10)*BCALC(1,i)*(1-PER(i,j)^NEIGHCOUNT(i)); %reviewed with X"   ***PER(i,j)
 if PINF(1,i) < 0
     disp('PINF 1 < 0!'); % It never happens, ok!
     PINF(1,i) = 0; % Just set it to minimum(=0) so that the old value is not retained
 end
 ENERGYSPENTCALC(1,i)=(pktsize*OVERHEAD(MODE(i))*bitTxcost)*BCALC(1,i);
 
 % Policy #2 - change mode, keep beta
 
 if MODE(i) > 1 && MODE(i) < 6
     MODECALC(2,i) = MODE(i) + MODEFACTOR(i); % I CHECK BEFORE CHANGING MODE ******************************
 else MODECALC(2,i) = MODE(i);  % ADDITION!!!! MODECALC SHOULD NOT STAY 0
 end
 
 PERCALC(2,i) = AN(MODECALC(2,i))*exp(-GN(MODECALC(2,i))*S2(i,:,t)); % THIS IS OK, THE NEW AN AND GN ARE USED ******************************
 
 if PERCALC(2,i) > 1
     PERCALC(2,i) = 1;
 end
 
 % PINF(2,i) = (0.01*abs(randn(1))+1) * ( (1-PERCALC(2,i)) *(1-B(i))^NEIGHCOUNT(i) ); % X" PINF calculation
 PINF(2,i) = (0.01*abs(randn(1))+1)*(1-B(i)/10)*B(i)*(1-PERCALC(2,i)^NEIGHCOUNT(i)); %reviewed with X"
 if PINF(2,i) < 0
      disp('PINF 2 < 0!');
 end
 ENERGYSPENTCALC(2,i)=(pktsize*OVERHEAD(MODECALC(2,i))*bitTxcost)*B((i));
 
 % Policy #3 - change mode, change beta
 
 BCALC(3,i) = B(i) + BFACTOR(i)*deltabeta;  % I CHECK BEFORE CHANGING B *******************************
 
 if MODE(i)<6 && MODE(i) > 1
     MODECALC(3,i) = MODE(i) + MODEFACTOR(i); % I CHECK BEFORE CHANGING MODE *******************************
 else
     MODECALC(3,i) = MODE(i);
 end
 PERCALC(3,i) = AN(MODECALC(3,i))*exp(-GN(MODECALC(3,i))*S2(i,:,t)); % THIS IS OK, THE NEW AN AND GN ARE USED ******************************
 
 if PERCALC(3,i) > 1
     PERCALC(3,i) = 1;
 end
 
 % PINF(3,i) = (0.01*abs(randn(1)) + 1)* ( weight*(1-PERCALC(3,i))*(1-BCALC(3,i))^NEIGHCOUNT(i)); % X" --- the factor weight* is arbitrary weight to enhance the choice of this policy
 PINF(3,i) = (0.01*abs(randn(1)) + 1)*(1-BCALC(3,i)/10)*BCALC(3,i)*(1-PERCALC(3,i)^NEIGHCOUNT(i)); %reviewed with X"
 if PINF(3,i) < 0
       disp('PINF 3 < 0!');
 end
 ENERGYSPENTCALC(3,i)=(pktsize*OVERHEAD(MODECALC(3,i))*bitTxcost)*BCALC(3,i);
 
 % Policy #4 - keep mode, keep beta
 
 BCALC(4,i) = B(i);
 MODECALC(4,i) = MODE(i);
 AUXPERCALC = mean(PER,1);       % ***PER(i,j)
 PERCALC(4,i) = AUXPERCALC(i);   % ***PER(i,j)
 
 % PINF(4,i) = (0.01*abs(randn(1)) + 1)*((1-PER(i))*(1-B(i))^NEIGHCOUNT(i));  % X"
 PINF(4,i,peer_of_i) = (0.01*abs(randn(1)) + 1)*(1-B(i)/10)*B(i)*(1-PER(i,peer_of_i)^NEIGHCOUNT(i)); %reviewed with X"
 for peer_of_i = 1:N
    PINFAUX(4,i) = PINF(4,i) + PINF(4,i,peer_of_i);
 end % peer_of_i
 PINF(4,i) = PINFAUX(4,i)/N;
 
 ENERGYSPENTCALC(4,i)=(pktsize*OVERHEAD(MODE(i))*bitTxcost)*B((i));
 
 % End of different options - policies
 
 if sum(MODE(i))>10
     disp('ALARM!!');
 end
 
 % Start of decision making:
   
  for policyindexx  = 1:4;
%    METRIC1(policyindexx,i) = PINF(policyindexx,i)/ENERGYSPENTCALC(policyindexx,i);
%    METRIC2(policyindexx,i) = PINF(policyindexx,i);
%    METRIC4(policyindexx,i) = PINF(policyindexx,i) - ENERGYSPENT(i)/(maxcostsingle*t);
%    METRIC5(policyindexx,i) = PINF(policyindexx,i) - (ENERGYSPENT(i)+ENERGYSPENTCALC(policyindexx,i))/(maxcostsingle*(t+1));  % modification to include the next time slot
%    METRIC3(policyindexx,i) = PINF(policyindexx,i)*(maxcostsingle-ENERGYSPENTCALC(policyindexx,i));  % 2*10^7 is an arbitary maximum cost
%   METRIC6(policyindexx,i) = DUPRATE(i) - ENERGYSPENT(i)/(maxcostsingle*t);
    METRIC7(policyindexx,i) = DUPRATE(i) - ENERGYSPENT(i)/(maxcostsingle*t)-changes_count(i,max(1,t-1))/(max(1,t-1));

  end
  
   
 % Calculate Utility if mode and beta do not change
 %UUNCH(i,t) = METRIC4(4,i);
 %
 % Calculate expected Utility over all possible future choices
 %  UUNCH(i,t) = 0.25*(METRIC6(1,i) + METRIC6(2,i) + METRIC6(3,i) + METRIC6(4,i) );
 % UUNCH(i,t) = (SSS(i,1)/t)*METRIC6(1,i) + (SSS(i,2)/t)*METRIC6(2,i) + (SSS(i,3)/t)*METRIC6(3,i) + (SSS(i,4)/t)*METRIC6(4,i);
 UUNCH(i,t) = (SSS(i,1)/t)*METRIC7(1,i) + (SSS(i,2)/t)*METRIC7(2,i) + (SSS(i,3)/t)*METRIC7(3,i) + (SSS(i,4)/t)*METRIC7(4,i);

 %
  
  for jjj = 1:4                  % policy index
%       MMM(jjj) = METRIC3(jjj,i);  % Vector with policies of the current node
%       MMM(jjj) = METRIC6(jjj,i);  % Vector with policies of the current node
      MMM(jjj) = METRIC7(jjj,i);  % Vector with policies of the current node

  end
  
  metric = max(MMM);      %I find the element with the highest metric FOR THIS NODE
  
%  if t/T > 1/ebase
%      if U(i,t)>=max(U(i,t))
%         disp('optimal stopping condition fulfilled!!')
%         disp('will now examine best policy to change mode!!') 
        
        for pindex  = 1:4;              % yes, policy index
           %    if metric == PINF(pindex,i)*(maxcostsingle-ENERGYSPENTCALC(pindex,i))  %  mitrechnen Energie & Infekzionprobabilitaet METRIC3
           %    if metric == PINF(pindex,i) - ENERGYSPENT(i)/(maxcostsingle*t); % METRIC 4
           %    if metric == PINF(pindex,i) - (ENERGYSPENT(i)+ENERGYSPENTCALC(policyindexx,i))/(maxcostsingle*(t+1)); % modif 2 inc next t-slot METRIC5
           %    if metric == DUPRATE(i) - ENERGYSPENT(i)/(maxcostsingle*t); % METRIC6
           if metric == DUPRATE(i) - ENERGYSPENT(i)/(maxcostsingle*t)-changes_count(i,max(1,t-1))/(max(1,t-1)); % METRIC7
          
                    % Calculation of potential benefit/reward/utility - start
                    
%                      UTEMP(i,t) = PINF(pindex,i) - ENERGYSPENT(i)/(maxcostsingle*t);

                    % Calculation of potential benefit/reward/utility - end
                    % Start of optimal stopping condition
                    if t/T > 1/ebase % dummy, always true; placeholder
%                         if U(i,t)>=max(U(i,t))

%                         if U(i,t)>max(AVEUT(i,t-1))    % check that it is higher than ever before % OST condition
                        if U(i,t)>UUNCH(i,t)           % check that it is higher than the utility if state does not change = U-UNCHanged % OST condition      
                            
                               (AVEUT(i,t)>max(AVEUT(i,t-1)));
%                                     disp('optimal stopping condition fulfilled!!')
%                                     disp('will now examine best policy to change mode!!') 
                                    % policy adoption start
                                    BTEMP(i) = BCALC(pindex,i);                             % policy adoption
%                                    MODETEMP(i) = MODECALC(pindex,i);                       % policy adoption
                                    POLICYCHOSEN(i,pindex) = POLICYCHOSEN(i,pindex)+1;      % policy popularity update
                                    
                                    if B(i)~= BTEMP(i) || MODE(i) ~= MODETEMP(i)
%                                         S(i,B(i),MODE(i),BTEMP(i),MODETEMP(i)) = S(i,B(i),MODE(i),BTEMP(i),MODETEMP(i)) + 1; % counter update
                                        SSS(i,pindex) = SSS(i,pindex) + 1;
                                    end
                                    
                                    % policy adoption end
                        else   % utility
                               % disp('no benefit');
                        end    % utility
                    end   % t/T > 1/ebase
                    ENORM(i,t) = ENERGYSPENT(i)/(maxcostsingle*t);
%                     UTEMP(i,t) = PINF(pindex,i) - ENERGYSPENT(i)/(maxcostsingle*t);
                    UTEMP(i,t) = metric;
                    U(i,t)=UTEMP(i,t);      % UTILITY CALCULATED HERE!!                  
                   % End of optimal stopping condition          
           end             
        end
% End of decision making      
        
 % Start of optimal stopping condition
%  ebase =2.718;
%   if t/T > 1/ebase
%       if U(i,t)>=max(U(i,t))
%          disp('optimal stopping condition fulfilled!!')
%          disp('will now examine best policy to change mode!!') 
%         ----------->here here here decide<------------
%       end
      %      disp('no benefit**');      %      do nothing
%   else
      %      disp('not yet*');     %      do nothing
%   end
   % End of optimal stopping condition
        
             if MODETEMP(i) > MODE(i)
                 UPMODE(i) = UPMODE(i)+1;
             end
             if MODETEMP(i) < MODE(i)
                 DOWNMODE(i) = DOWNMODE(i)+1;
             end

           end %RX(i)
           if RX(i)==0
	            %BTEMP(i) = b0; %whichever you like most. the second is more 'natural'
	            BTEMP(i) = B(i);
	         end 
	              
	    end % i
	    
	    A = ATEMP;
%       B = BTEMP;
	    TX = TXTEMP;
	    RX = RXTEMP;
	    ERR = ERRTEMP;
	    DUP = DUPTEMP;
        SUCCESSFUL_INF_COUNT = SUCCESSFUL_INF_COUNT_TEMP;	    
        
        for node20 = 1:N
            if (MODETEMP(node20) ~= MODE(node20)) | (BTEMP(node20) ~= B(node20))
                WINDOW(node20) = 1;% reset window size at node state change
                    changes_count(node20,t) = changes_count(node20,max(1,t-1)) + 1;                
%                 disp('STATE CHANGE!!');
            else
                WINDOW(node20) = WINDOW(node20)+1;
                    changes_count(node20,t) = changes_count(node20,max(1,t-1));                    
            end
        end
        
 	    MODE = MODETEMP;
        ERRRATE = ERRRATETEMP;
	    DUPRATE = DUPRATETEMP;
        MODEDET(t,:)=MODE;
        BDET(t,:)=B;        
%         CHANSTATE = CHANSTATETEMP;
%         UPIFSMC = UPIFSMCTEMP;
%         DOWNIFSMC = DOWNIFSMCTEMP;
%         SWITCHIFSMC = DOWNIFSMC + UPIFSMC;
        
        %checking if full infection has been achieved
        %disp('INFECTION RATE:')
        %disp(sum(A)/N);
        if sum(A)/N==1
            
            if TC2FC(iteration)==0   % if T2FC = 0, then the others are zero too
                %disp('FULL INFECTION!');
                %disp('...needed only...')
                %disp(sum(TX));
                %disp('transmissions');
%                 TC2FC(iteration)=sum(TX);
                TC2FC(iteration)=sum(nonzeros(TX));
                T2FC(iteration)=t;
%                 E2FC(iteration)=sum(ENERGYSPENT)/N;
                E2FC(iteration)=mean(nonzeros(ENERGYSPENT));
            end
        end
	
        if sum(A)/N==0.9
            if TC29C(iteration)==0   % if T29C = 0, then the others are zero too
                %disp('90% INFECTION!');
%                 TC29C(iteration)=sum(TX);
                TC29C(iteration)=sum(nonzeros(TX));
                T29C(iteration)=t;
%                 E29C(iteration)=sum(ENERGYSPENT)/N;
                E29C(iteration)=mean(nonzeros(ENERGYSPENT));
            end
        end        
        
	    betasum = 0;
	    for bindex = 1:N
	        betasum = betasum + B(bindex);
        end
        %Bdetailed(node,t) = B(index); %must average over iterations later
	    betaave = betasum/N;
% 	    B = BTEMP;
	    
	    I = sum(A)/N; %proportion of infected nodes
	    Ivstime(iteration,t) = I;
	    Bvstime(iteration,t) = betaave;

        %Calculate average mode
	    modesum = 0;
	    for mindex = 1:N
	        modesum = modesum + MODE(mindex);
        end

	    modeave = modesum/N;
	    %MODE = MODETEMP; %no need, done already
	    
	    Modevstime(iteration,t) = modeave;
        Chanstatevstime(iteration,t) = mean(CHANSTATET(t,:));
        
        DUPRATET(t) = sum(DUPRATE)/N;
        ERRRATET(t) = sum(ERRRATE)/N;         
        
        DUPRATEI(iteration,t) = DUPRATET(t);
        ERRRATEI(iteration,t) = ERRRATET(t);        
        
	end % t
    
    IES(iteration) = sum(ENERGYSPENT)/N; %Iteration Energy Spent
    %disp('average over nodes -- energy spent was.......')
    %disp(IES(iteration));
    
    OBS(iteration) = sum(OVERHEADBITSENT)/N; % Overhead Bits Sent
    %disp('average over nodes -- overhead bits tansmitted were...')
    %disp(OBS(iteration));
    
    TBS(iteration) = sum(BITSENT)/N; % Total Bits Sent
    
    TRANS(iteration) = sum(TX)/N; % Total Messages Sent
    %disp('average over nodes -- total messages transmitted were...')
    %disp(TRANS(iteration));

    REC(iteration) = sum(RX)/N; % Total Messages Received
    %disp('average over nodes -- total messages received were...')
    %disp(REC(iteration));    
     
    DUPLIC(iteration) = sum(DUP)/N; % Average Duplicate Messages Received per Node
    %disp('average over nodes -- duplicate messages received were...')
    %disp(DUPLIC(iteration));
    
    ERRORS(iteration) = sum(ERR)/N; % Corrupt Messages Received
    %disp('average over nodes -- duplicate messages transmitted were...')
    %disp(ERRORS(iteration));
    

    %DUPTT = sum(DUPT,1)/iterations;
    
    %disp('infected nodes!')        
    %disp(sum(A))

    III(iteration) = sum(A); 
    
    TXCOUNT(iteration) = sum(TX);
    RXCOUNT(iteration) = sum(RX);    
    
    UPI(iteration) = sum(UP)/N;
    DOWNI(iteration) = sum(DOWN)/N;
    
    UPMODEI(iteration)=sum(UPMODE)/N;
    DOWNMODEI(iteration)=sum(DOWNMODE)/N;
    
%     for policyi=1:4;
%         for nodei=1:N;
%             POLICYCHOSENI(iteration,policyi) = mean(POLICYCHOSEN);
%         end
%     end
    
    AUXP = mean(POLICYCHOSEN); % auxiliary matrix
    
    for indexx=1:4;
        POLICYCHOSENI(iteration,indexx) = AUXP(indexx);
    end

    changes_count_global(:,:,iteration) = changes_count;
    SUCCESSFUL_INF_COUNT_GLOBAL(iteration,:) = SUCCESSFUL_INF_COUNT;    
%     POLICYCHOSENI(iteration) = mean(POLICYCHOSEN);%ioioioioio
    
end % iteration  

xx=clock;
hour=num2str(xx(4));
minu=num2str(xx(5));
diary(strcat('NAMC_',date,'_',hour,'_',minu,'.csv'));
diary on;

%disp('start timestamp:');
%xx

        disp('===Input===');
	disp('YES this IS based on NAMC208!!')
        disp('Stable beta and Mode acc.to STATIC AMC - Yannakis scheme!!');
        disp('Number of nodes');
        disp(N);
        disp('Beta orig');
        disp(randobeta);
        disp('Starting mode');
%        disp(startingmode);  
        disp(MODESTART);              
        disp('Temporal duration');
        disp(T);
%         disp('signal');
%         disp(signal);
        disp('noise mean');
        disp(n0);
        disp('noise sigma');
        disp(sigma);
        disp('noise burst amplitude');
        disp(nb);        
        disp('delta over beta');
        disp(deltaoverbeta);
        disp('pkt size');
        disp(pktsize);
        disp('network density i.e. adjacency probability');
        disp(netdens);
        disp('Number of iterations');
        disp(iterations);
        disp('sliding window at simulation conclusion');
        disp(WINDOW);
        disp('temporal threshold to start optimal stopping conditionevaluation');
        disp(1/ebase);
        
        
        
    disp('===Output===');
%start calculate mode popularity  
for i=1:6 % number of modes
            POPULARITY(i)=0;
end %modes

for i=1:6 % number of modes
    for n=1:N % number of nodes
        if MODE(n)==i %if mode
            POPULARITY(i)=POPULARITY(i)+1;
        end %if mode
    end %nodes
end %modes    
    
%end calculate mode popularity  

DR = sum(DUPRATEI,1)/iterations;
ER = sum(ERRRATEI,1)/iterations;

    disp('BER exceeded 1 this many times...');
    disp(berrors);
    disp('So the proportion of bad PERs is...');
    disp(100*berrors/(berrors+bergood));    

    Iavevstime = sum(Ivstime,1)/iterations;
    Bavevstime = sum(Bvstime,1)/iterations;
    Modeavevstime = sum(Modevstime,1)/iterations;    

    Chanstateavevstime = sum(Chanstatevstime,1)/iterations;

    Bitsentave = sum(TBS)/iterations;
    disp('average bits transmitted (average over nodes & iterations)...')
    disp(Bitsentave);       
    
    Duplicatemsgsave = sum(DUPLIC)/iterations;
    disp('average duplicate messages (average over nodes & iterations)...')
    disp(Duplicatemsgsave); 
    
    Transmsgsave = sum(TRANS)/iterations;
    disp('average total messages Txd (average over nodes & iterations)...')
    disp(Transmsgsave); 
    
    Recmsgsave = sum(REC)/iterations;
    disp('average total messages Rxd (average over nodes & iterations)...')
    disp(Recmsgsave);    

    Overheadbitsave = sum(OBS)/iterations;
    disp('average overhead sent (average over nodes & iterations)...')
    disp(Overheadbitsave);    
    
    Corrupt=sum(ERRORS)/iterations;
    disp('average corrupt messages Rxd (average over nodes & iterations)...')
    disp(Corrupt);       

    txcount=sum(TXCOUNT)/iterations;
    disp('average total transmissions (average over nodes & iterations)...');
    disp(txcount);
    
    rxcount=sum(RXCOUNT)/iterations;
    disp('average total receptions (average over nodes & iterations)...');
    disp(rxcount);    

    up = sum(UPI)/iterations;
    disp('average times beta was incremented (average over nodes & iterations)...');
    disp(up);

    down = sum(DOWNI)/iterations;
    disp('average times beta was decremented (average over nodes & iterations)...');        
    disp(down);    
    
    upmode = sum(UPMODEI)/iterations;
    disp('moved to higher mode this many times...')
    disp(upmode);    
    
    downmode = sum(DOWNMODEI)/iterations;
    disp('moved to lower mode this many times...')
    disp(downmode);   
    
    disp('--- --- ---');
    
    Duorec=Duplicatemsgsave/Recmsgsave; %DUplicatesOverRECeived in total
    disp('average duplicates ratio (average over nodes & iterations)...')
    disp(Duorec);       
     
    Corec=Corrupt/Recmsgsave; %CorruptOverRECeived Rxd
    disp('average Corrupt msgs ratio (average over nodes & iterations)...')
    disp(Corec);    
    
    Ohotot=Overheadbitsave/Bitsentave; %OverHeadOverTOTal
    disp('average overhead ratio (bits over total bits) - (average over nodes & iterations)...')
    disp(Ohotot);     

    disp('average infection rate...');
    disp(sum(III)/iterations/N);    
  
    upmoderatio = upmode/(upmode+downmode);
    disp('mode increments % of all transitions...')
    disp(upmoderatio*100);
      
    downmoderatio = downmode/(upmode+downmode);
    disp('mode decrements % of all transitions...')
    disp(downmoderatio*100);        
    
    upratio = up/(up+down);
    disp('beta increments % of all transitions...')
    disp(upratio*100);
      
    downratio = down/(up+down);
    disp('beta decrements % of all transitions...')
    disp(downratio*100);     
    
     disp('###############')
    disp('static scheme');
    disp('**************');        
    Energyspentave = sum(IES)/iterations;
    str1 = ['ETOTAL, average energy spent (average over nodes & iterations)...,',num2str(Energyspentave)];
    disp(str1);
    disp('**************');     
    
%     e2fc=(sum(nonzeros(E2FC))/iterations);
    e2fc=(sum(nonzeros(E2FC))/nnz(E2FC));
    str2 = ['E2FC , Energy to FC,',num2str(e2fc)];
    disp(str2);
    
%     tc2fc=sum(nonzeros(TC2FC))/iterations;
    tc2fc=sum(nonzeros(TC2FC))/nnz(TC2FC);
    str3=['TC2FC , average transmissions to achieve full infection (average over iterations ONLY)...,  ',num2str(tc2fc)];
    disp(str3);
    
%     t2fc=sum(nonzeros(T2FC))/iterations;
    t2fc=sum(nonzeros(T2FC))/nnz(T2FC);
    str4=['T2FC , average time to reach full coverage (average over iterations ONLY)...,  ',num2str(t2fc)];
    disp(str4);      
 
%     e29c=(sum(nonzeros(E29C))/iterations); 
    e29c=sum(nonzeros(E29C))/nnz(E29C);
    str5=['E29C , Energy to 90% coverage,  ', num2str(e29c)];
    disp(str5);
    
%     tc29c=sum(nonzeros(TC29C))/iterations;
    tc29c=sum(nonzeros(TC29C))/nnz(TC29C);
    str6=['TC29C , average transmissions to achieve 90% infection (average over iterations ONLY)...,  ',num2str(tc29c)];
    disp(str6);
    
%     t29c=sum(nonzeros(T29C))/iterations;
    t29c=sum(nonzeros(T29C))/nnz(T29C);    
    str7=['T29C , average time to reach 90% coverage (average over iterations ONLY)...,',num2str(t29c)];
    disp(str7);      

    str8=['E/T2FC , Energy/Time 2FC,  ',num2str(e2fc/t2fc)];
    disp(str8);
    
    str9=['E/TC2FC , Energy/Tx 2FC,  ',num2str(e2fc/tc2fc)];    
    disp(str9);        
    
    str10=['E29C/T29C , Energy/Time to 90% coverage,  ',num2str(e29c/t29c)];    
    disp(str10);
    
    str11=['E29C/TC29C , Energy/Tx_count to 90% coverage,  ',num2str(e29c/tc29c)];     
    disp(str11);
    
    efficiency=(sum(III)/iterations/N)/tc2fc;
    str12=['efficiency,  ', ' average infection rate/tc2fc, ' ,num2str(efficiency)];    
    disp(str12);   
    
%     disp('Infection rate, Infection rate,')
%     disp(Iavevstime(T)); 
    
    str13=['Infection rate,  ', ' Infection rate, ' ,num2str(Iavevstime(T))];    
    disp(str13);

    str14 = ['Count of successful infections, ', 'Count of successful infections, ' ,num2str(  sum(  mean(SUCCESSFUL_INF_COUNT_GLOBAL,1)       )   )];
    disp(str14);

    si = sum(mean(SUCCESSFUL_INF_COUNT_GLOBAL,1));
    g_eff = pktsize*si/e2fc; % effective goodput;
    str15=['Effective Goodput, ', 'Effective Goodput, ',num2str(g_eff)];
    disp(str15);
    
      disp('POLICY popularities are:');
      OUTPOLICYPOPU=mean(POLICYCHOSENI);
%     disp('keep mode-change beta, change mode-keep beta, change
%     mode-change beta, keep mode-keep beta');
%     str13=[num2str(OUTPOLICYPOPU(1)),' , ',num2str(OUTPOLICYPOPU(2)),' , ',num2str(OUTPOLICYPOPU(3)),' , ',num2str(OUTPOLICYPOPU(4))];
%     disp(str13);

%     str131=['keep mode-change beta, ',num2str(OUTPOLICYPOPU(1))];
%     str132=['change mode-keep beta, ',num2str(OUTPOLICYPOPU(2))];
%     str133=['change mode-change beta, ',num2str(OUTPOLICYPOPU(3))];
%     str134=['keep mode-keep beta, ',num2str(OUTPOLICYPOPU(4))];          

    str131=['keep mode-change beta, ','keep mode-change beta, ',num2str( OUTPOLICYPOPU(1)/(sum(OUTPOLICYPOPU)) )  ];
    str132=['change mode-keep beta, ','change mode-keep beta, ',num2str(OUTPOLICYPOPU(2)/(sum(OUTPOLICYPOPU)))];
    str133=['change mode-change beta, ','change mode-change beta, ',num2str(OUTPOLICYPOPU(3)/(sum(OUTPOLICYPOPU)))];
    str134=['keep mode-keep beta, ','keep mode-keep beta, ',num2str(OUTPOLICYPOPU(4)/(sum(OUTPOLICYPOPU)))];
    
    disp(str131);
    disp(str132);
    disp(str133);
    disp(str134);
    
    diary off;

    %
%     disp('### RESULTS IN CSV FORM ###')
%     superstring1 = ['scheme,','Energy spent,','E2FC,','TC2FC,','T2FC,','E29C,','TC29C,','E2FC/T2FC,','E2FC/TC2FC,','E29C/T29C,','E29C/TC29C'];
%     superstring2 = ['AMC w/ static beta,',Energyspentave,'',e2fc,'',tc2fc,'',t2fc,'',e29c,'',tc29c,'',e2fc/t2fc,'',e2fc/tc2fc,'',e29c/t29c,'',e29c/tc29c];
%     disp(superstring1);
%     disp(superstring2);

    %
	    t=1:T;
	    
        %h = line(t,Iavevstime,'linestyle','--')
        %set(h,'LineWidth',1.5)
%         

        %plot(t,Bavevstime(t),'g');
        %plot(t,Modeavevstime(t),'g');
        %plot(t,ERRRATET,'g');
        %plot(t,DUPRATET,'g');
	    %xlabel('time')
	    %ylabel('coverage rate');
        %ylabel('forw. prob');    
        %ylabel('average encoding mode');
        %hold on;
	    %title('average beta, infection rate vs time')
	    %legend('average forwarding rate')     
	    
%             nodei = 1:N;
%             plot(nodei,ENERGYSPENT(nodei),'k');
        
        %mode=1:6;
        %plot(mode,POPULARITY,'r--');
        

        AVEUT1 =AVEUT(1,:);
        AVEUT2 =AVEUT(2,:);
        AVEUT3 =AVEUT(3,:);
        AVEUT10=AVEUT(10,:);
%         AVEUT50=AVEUT(50,:);
        AVEUTN=AVEUT(N,:);
        
%         plot(AVEUT1(:)); 
%         hold on;
%         plot(AVEUT2(:),'r')
%         plot(AVEUT3(:),'g')
%         plot(AVEUT10(:),'k')
%         plot(AVEUT50(:),'b--')
%         hold on;              
        
        %orient landscape
        %print -dps C:\plot_TEST.ps      
        %print -dps 'C:\Documents and Settings\USER\My Documents\_Wonders\_My_Work\04_Adaptive_Epidemics\09_WCNC_2012\Simulation_Results\15\plot_TEST.ps'
        
        yy = clock;
        disp('end timestamp');
        yy
        disp('duration');
        yy-zz          
disp('=========');
disp('===Yannakis SCHEME ===');
disp('== END ==')
% save NAMC208_static_callable
filename = ['NAMC_' num2str(iterations) '_' date '_' hour '_' minu '.mat'];
save(filename);

end
ations) '_' date '_' hour '_' minu '.mat'];
save(filename);

end
